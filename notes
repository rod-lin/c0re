关于ucore所有lab版本(lab1 - lab8)以及版本过渡的一些笔记

大部分文件名和函数名与ucore里的是一样的。。有一些强迫症范了偏要改名请见谅。

lab1 
    @19082017
        因为这个笔记是lab2才开始的所以这里只能凭印象写一下lab1里面的大致内容
        lab1主要是一个最基本的，可以做启动，打印字符以及支持中断的一个操作系统框架
        没什么大坑毕竟也没有前面的版本过渡的问题
        
        一开始启动是bootasm.S
        bootasm.S这个版本里只有三个工作 -- 设置一个基本的GDT，切换到保护模式，布置栈并调到bootmain(在bootc.c里面)
        没什么毛病就主要一开始A20是什么鬼有点懵逼（似乎要用一个叫8042芯片的键盘控制器？？？（键盘控制器被委以如此重任表示很懵逼））
        然后每次改段寄存器都要ljmp一下不知道为什么（刷新？？） [TODO]
        段描述符的格式比较诡异，据说是要向下兼容的缘故。反正忘了就查维基吧。。
        然后设置了栈指针就跳到c
        
        bootc的功能是读磁盘加载内核
        也没什么毛病大部分就是磁盘接口以及ELF的格式（15-213全忘光了。。）
        
        然后华丽跳转到内核
        
        内核的初始化就开始懵逼了。
        主要一些基本的模块都相互依赖（输入输出(console.c)依赖中断，然后中断和其他东西实现的地方又有很多要输出调试的地方。。）
        于是就一点一点撸最后终于搭出来了。
        
        首先driver里面就是一堆驱动。各种输入输出初始化啥的。。感觉参数端口啥的不查表鬼才记得住。
        clock.c 是时钟驱动，现在是rate generator模式，应该就是隔一段时间发出一个中断
        然后那个时钟芯片（8253）有个很诡异的频率1193182Hz，每次用都要换算一下
        最后设置的那个数字不是中断的间隔而是1秒中断的次数（16-bit整数，ucore里面获得高地位的模和除让我一开始很懵逼//）

        console就是字符输入输出没毛病，就是输入字符里面控制字符做的比较草率还要改一下
        
        pic就是外围设备的终端控制器。像timer，键盘啥的都要enable一下才能关闭屏蔽
        
        然后就是intr中断，里面所有东西基本上就是在初始化IDT，vectors.S是一个很诡异的中断处理函数的列表，并不是正式的中断描述符，
        只是方便trap.c里面初始化用。然后现在是所有中断都会被vectors.S里面的某个函数设置了中断号之后跳到trapentry.S，
        然后trapentry再调到trap.c里面的alltrap做分开处理
        
        最后一个比较大的一块是mem，这里的mem就是基本的一些布局(mmu.h，我把mem_layout合并到了这里)和基本GDT初始化(pmm.c)。
        这一块lab2里改动很大之后再讲。
        
        其他就是辅助函数，以及一个简单的“标准库” libs(我改成了pub)
        没了

lab1 -> lab2
    @19082017
        好多坑，简单记一下
        1. tool里面多了一个boot.ld（链接时候的脚本）, （我觉得是）因为bootasm.S里面多了一个内存探查引导就可能太大了
          （要小于等于512 - 2 = 510 byte）。。
           于是就只能链接的时候简化一下？？ 这个当时调试了很久（WTF命令都一样啊为什么我编译出来的就大一点！！！）
        2. 由于要支持虚拟内存分页机制，tool/kernel.ld和init（多了个entry.S）都有更改。注意要把qemu的内存改大一点
          （好像小于4G还是多少就会崩溃）
        3. 然后console和一些驱动里面地址都有改过（因为内核加载地址改了）

    @20082017
        potential bugs(search TODO):
        1. ffit.c
        2. x86.h
        3. line 34 pmm.c (typo)
        4. line 394 in pmm.c(in labcodes_answer), it should be PTE_ADDR?
        5. the memset at the begining of kern_init may clear the allocator?
        
        终于调完分页的东西了。。主要页分配器要注意测试。。一个超蠢的bug调了一个下午
        主要基于页的地址转换比较绕，特别是马上要打开分页那一小段要仔细考虑才能让代码正常运行
        查了半天段页式的内存管理觉得好难后来发现ucore也没有真正利用分段（只是一开始简单换算一下，最后直接映射了）。不知道后面会不会改。
        
        主要还是有些地方有些小问题。。比如为什么要把0xC0000000当内核基址。。
        
        然后键盘中断稍微有点诡异输入都是乱码。。没时间调了明天看

lab2 -> lab3
    @26082017
        隔了一星期忘得差不多了。。。
        
        lab3最主要的部分就是虚拟内存的管理和swap的实现
        现在内存管理还是有点迷迷糊糊的。。下面尝试总结一下

        最基本的就是物理内存，就是一个纯洁的大数组，没有任何诡异的魔法，一个地址对一个实际内存单元从0开始没毛病
        然而由于各种奇怪的需求，地址转换的魔法就诞生了！！
        
        所以一共有三种地址
            逻辑地址
            线性地址
            物理地址
            
        逻辑地址就是你向cpu请求的地址。基本上程序中你要取值的那些地址全都是逻辑地址，即使它可能一开始和线性地址和物理地址一样。
        我的理解方式就是cpu读写内存时只接受逻辑地址，地址转换是cpu自己的事
        
        而线性地址和物理地址就和内存管理方式相关。他们的联系应该就是
        
                   分段                分页
        逻辑地址 ---------> 线性地址 ---------> 物理地址
        
        然后就出现了两种内存管理方式：段式和页式
        
        段式由GDT和LDT表管理，这是os启动最开始要用到的内存管理方式。pmm.c里面有一小部分配置GDT的（但实际上ucore最后也会舍弃分段）
        页式由页表管理（x86有两级），ucore会把全部可用内存分成一般大小为4k的物理页，然后交由page_allocator管理（ucore里面）
        
        这里要注意的是物理的‘分配’和‘释放’实际上都是ucore自己定义的属性，页表本身只负责地址转换。
        
        所以总的来说段式和页式的内存管理方式就是通过几张表来把逻辑地址转换成物理地址。
        
        ------------- 这是硬件层面支持的转换
        
        虚拟内存
        
        虚拟内存我个人觉得是在操作系统层面实现的一种技术，可以一定程度扩大实际物理内存大小
        基本上虚拟内存这样工作（有一些是我yy的因为好像是lab4的内容）

        每个进程有一个page directory和一个memory map
        一开始这个page directory是全空的
        而memory map记录了可以访问的段（实际上就像一个自己做的段表，每个段可以变长，还可以有读写属性）
        
        然后程序开始执行的时候，尝试读指令，于是page fault（这个中断我猜是cpu发现一个地址对应page dir中内容为空的时候触发的）。
        于是内核的中断处理程序就会分配一个空物理页，然后把这个物理页绑定到page dir中，然后程序就可以继续读东西了
        
        所以（开始yy）page dir和memory map两个东西的组合就像定义了一层虚拟的内存，而实际的内存则由物理页分配器分配（page_allocator）
        然后程序结束之后操作系统再释放页表和其中所有的页。
        
        然后通过这样一层抽象，交换内存的技术就可以实现。
        
        swap就是主动（比如按时间间隔）或者被动（没内存的时候）地把一些不怎么用的页塞到硬盘
        然后等page fault了之后再取出来
        
        ucore里面的具体实现还有很多没看懂以后补。。
